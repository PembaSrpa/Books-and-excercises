---
key: "chapter-4"
title: "Chapter 4"
date: "2026-01-18"
description: "Functions and Interfaces"
tags: ["Python", "Turtle", "Interface Design", "Refactoring"]
---

# Functions and Interfaces

Chapter 4 uses the `turtle` module to introduce the concept of an **Interface**â€”the set of functions a programmer provides to solve a specific problem.

## 1. The Turtle Module
The `turtle` module (using `jupyturtle` for notebook environments) allows us to create graphics by moving a "turtle" around a **canvas**.
- **The Object:** `make_turtle()` initializes the canvas.
- **Methods:** Commands like `forward(length)` and `left(angle)` move the turtle.
- **Refinement:** Functions like `penup()` and `pendown()` allow the turtle to "jump" without leaving a trail.

## 2. Encapsulation & Generalization
The development plan follows a specific evolution:
- **Encapsulation:** Wrapping a sequence of statements in a function. This attaches a name to the code, serving as documentation.
- **Generalization:** Replacing specific values (like a fixed length) with variables/parameters to make the function versatile.



## 3. Refactoring
**Refactoring** is the process of modifying a working program to improve the function interfaces without changing its behavior.
- **Example:** We first wrote `circle` using `polygon`. Later, we created `polyline` and `arc`. We then refactored `circle` to call `arc(radius, 360)`.
- **Lesson:** Refactoring is often a sign that you have learned a more efficient way to structure your logic.

## 4. Stack Diagrams for Interfaces
When functions call other functions, the "stack" tracks the local parameters.
- **Local Scope:** You can use the same name (like `angle`) in `arc` and `polyline`. They are different variables and do not interfere with each other.



## 5. Implementation vs. Interface
- **Interface:** The "contract." How the function is used (name, parameters, expected result).
- **Implementation:** The "mechanics." How the function achieves the result.
- **Key Insight:** You can change the *implementation* (e.g., refactoring `circle`) without breaking the *interface* for the user.

## 6. Docstrings & Documentation
A **docstring** is a triple-quoted string at the start of a function. It is a "Best-in-Class" requirement for professional code.
It should explain:
1. What the function does.
2. What each parameter represents.
3. The expected types of the parameters.

## 7. Debugging: Preconditions & Postconditions
- **Precondition:** A requirement the *caller* must satisfy before the function starts (e.g., `radius` must be positive).
- **Postcondition:** A requirement the *function* must satisfy before it ends (e.g., the turtle ends at a specific orientation).
- **Rule:** If the precondition is met but the output is wrong, the bug is in the function. If the precondition is violated, the bug is in the caller.

## 8. Development Plan Summary
1. Start with a small program (no functions).
2. **Encapsulate** a working piece into a function.
3. **Generalize** by adding parameters.
4. **Refactor** to improve interfaces and remove duplication.

---

### Exercises: Geometric Logic

#### The Snail and the Flower
I used `arc` to create complex biological patterns. A **petal** is composed of two arcs; by rotating the turtle between petals, we can generate a full **flower**.



#### Structural Shapes
I built a hierarchy of shapes where specific ones (Rectangle, Rhombus) are built on top of more general ones (Parallelogram).

```python
def polyline(n, length, angle):
    """Draws n line segments with given length and angle."""
    for i in range(n):
        forward(length)
        left(angle)

def parallelogram(t, width, height, angle):
    for i in range(2):
        forward(width)
        left(angle)
        forward(height)
        left(180-angle)

def rectangle(t, width, height):
    parallelogram(t, width, height, 90)
```

---
